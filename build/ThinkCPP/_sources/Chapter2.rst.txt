Variables and types
===================

More output
-----------

As I mentioned in the last chapter, you can put as many statements as
you want in main. For example, to output more than one line:

::

    #include <iostream>
    using namespace std;
    // main: generate some simple output

    int main ()
    {
      cout << "Hello, world." << endl;     // output one line
      cout << "How are you?" << endl;      // output another
      return 0;
    }

As you can see, it is legal to put comments at the end of a line, as
well as on a line by themselves.

The phrases that appear in quotation marks are called **strings**,
because they are made up of a sequence (string) of letters. Actually,
strings can contain any combination of letters, numbers, punctuation
marks, and other special characters.

Often it is useful to display the output from multiple output statements
all on one line. You can do this by leaving out the first endl:

::

    int main ()
    {
      cout << "Goodbye, ";
      cout << "cruel world!" << endl;
      return 0
    }

In this case the output appears on a single line as Goodbye, cruel
world!. Notice that there is a space between the word “Goodbye,” and the
second quotation mark. This space appears in the output, so it affects
the behavior of the program.

Spaces that appear outside of quotation marks generally do not affect
the behavior of the program. For example, I could have written:

::

    int main ()
    {
      cout<<"Goodbye, ";
      cout<<"cruel world!"<<endl;
      return 0;
    }

This program would compile and run just as well as the original. The
breaks at the ends of lines (newlines) do not affect the program’s
behavior either, so I could have written:

::

    int main(){cout<<"Goodbye, ";cout<<"cruel world!"<<endl;return 0;}

That would work, too, although you have probably noticed that the
program is getting harder and harder to read. Newlines and spaces are
useful for organizing your program visually, making it easier to read
the program and locate syntax errors.

Values
------

A value is one of the fundamental things—like a letter or a number—that
a program manipulates. The only values we have manipulated so far are
the string values we have been outputting, like "Hello, world.". You
(and the compiler) can identify string values because they are enclosed
in quotation marks.

There are other kinds of values, including integers and characters. An
integer is a whole number like 1 or 17. You can output integer values
the same way you output strings:

::

      cout << 17 << endl;

A character value is a letter or digit or punctuation mark enclosed in
single quotes, like ’a’ or ’5’. You can output character values the same
way:

::

      cout << '}' << endl;

This example outputs a single close squiggly-brace on a line by itself.

It is easy to confuse different types of values, like "5", ’5’ and 5,
but if you pay attention to the punctuation, it should be clear that the
first is a string, the second is a character and the third is an
integer. The reason this distinction is important should become clear
soon.

Variables
---------

One of the most powerful features of a programming language is the
ability to manipulate **variables**. A variable is a named location that
stores a value.

Just as there are different types of values (integer, character, etc.),
there are different types of variables. When you create a new variable,
you have to declare what type it is. For example, the character type in
C++ is called char. The following statement creates a new variable named
fred that has type char.

::

        char fred;

This kind of statement is called a **declaration**.

The type of a variable determines what kind of values it can store. A
char variable can contain characters, and it should come as no surprise
that int variables can store integers.

There are several types in C++ that can store string values, but we are
going to skip that for now (see Chapter \ `[strings] <#strings>`__).

To create an integer variable, the syntax is

::

      int bob;

where bob is the arbitrary name you made up for the variable. In
general, you will want to make up variable names that indicate what you
plan to do with the variable. For example, if you saw these variable
declarations:

::

        char firstLetter;
        char lastLetter;
        int hour, minute;

you could probably make a good guess at what values would be stored in
them. This example also demonstrates the syntax for declaring multiple
variables with the same type: hour and minute are both integers (int
type).

Assignment
----------

Now that we have created some variables, we would like to store values
in them. We do that with an **assignment statement**.

::

        firstLetter = 'a';   // give firstLetter the value 'a'
        hour = 11;           // assign the value 11 to hour
        minute = 59;         // set minute to 59

This example shows three assignments, and the comments show three
different ways people sometimes talk about assignment statements. The
vocabulary can be confusing here, but the idea is straightforward:

-  When you declare a variable, you create a named storage location.

-  When you make an assignment to a variable, you give it a value.

A common way to represent variables on paper is to draw a box with the
name of the variable on the outside and the value of the variable on the
inside. This kind of figure is called a **state diagram** because is
shows what state each of the variables is in (you can think of it as the
variable’s “state of mind”). This diagram shows the effect of the three
assignment statements:




I sometimes use different shapes to indicate different variable types.
These shapes should help remind you that one of the rules in C++ is that
a variable has to have the same type as the value you assign it. For
example, you cannot store a string in an int variable. The following
statement generates a compiler error.

::

      int hour;
      hour = "Hello.";       // WRONG !!

This rule is sometimes a source of confusion, because there are many
ways that you can convert values from one type to another, and C++
sometimes converts things automatically. But for now you should remember
that as a general rule variables and values have the same type, and
we’ll talk about special cases later.

Another source of confusion is that some strings *look* like integers,
but they are not. For example, the string "123", which is made up of the
characters 1, 2 and 3, is not the same thing as the *number* 123. This
assignment is illegal:

::

      minute = "59";         // WRONG!

.. _output:

Outputting variables
--------------------

You can output the value of a variable using the same commands we used
to output simple values.

::

      int hour, minute;
      char colon;

      hour = 11;
      minute = 59;
      colon = ':';

      cout << "The current time is ";
      cout << hour;
      cout << colon;
      cout << minute;
      cout << endl;

This program creates two integer variables named hour and minute, and a
character variable named colon. It assigns appropriate values to each of
the variables and then uses a series of output statements to generate
the following:

::

    The current time is 11:59

When we talk about “outputting a variable,” we mean outputting the
*value* of the variable. To output the *name* of a variable, you have to
put it in quotes. For example: cout << "hour";

As we have seen before, you can include more than one value in a single
output statement, which can make the previous program more concise:

::

      int hour, minute;
      char colon;

      hour = 11;
      minute = 59;
      colon = ':';

      cout << "The current time is " << hour << colon << minute << endl;

On one line, this program outputs a string, two integers, a character,
and the special value endl. Very impressive!

Keywords
--------

A few sections ago, I said that you can make up any name you want for
your variables, but that’s not quite true. There are certain words that
are reserved in C++ because they are used by the compiler to parse the
structure of your program, and if you use them as variable names, it
will get confused. These words, called **keywords**, include int, char,
void, endl and many more.

The complete list of keywords is included in the C++ Standard, which is
the official language definition adopted by the the International
Organization for Standardization (ISO) on September 1, 1998. You can
download a copy electronically from

::

        http://www.ansi.org/

Rather than memorize the list, I would suggest that you take advantage
of a feature provided in many development environments: code
highlighting. As you type, different parts of your program should appear
in different colors. For example, keywords might be blue, strings red,
and other code black. If you type a variable name and it turns blue,
watch out! You might get some strange behavior from the compiler.

Operators
---------

**Operators** are special symbols that are used to represent simple
computations like addition and multiplication. Most of the operators in
C++ do exactly what you would expect them to do, because they are common
mathematical symbols. For example, the operator for adding two integers
is +.

The following are all legal C++ expressions whose meaning is more or
less obvious:

::

    1+1        hour-1       hour*60 + minute     minute/60

Expressions can contain both variables names and integer values. In each
case the name of the variable is replaced with its value before the
computation is performed.

Addition, subtraction and multiplication all do what you expect, but you
might be surprised by division. For example, the following program:

::

      int hour, minute;
      hour = 11;
      minute = 59;
      cout << "Number of minutes since midnight: ";
      cout << hour*60 + minute << endl;
      cout << "Fraction of the hour that has passed: ";
      cout << minute/60 << endl;

would generate the following output:

::

    Number of minutes since midnight: 719
    Fraction of the hour that has passed: 0

The first line is what we expected, but the second line is odd. The
value of the variable minute is 59, and 59 divided by 60 is 0.98333, not
0. The reason for the discrepancy is that C++ is performing **integer
division**.

When both of the **operands** are integers (operands are the things
operators operate on), the result must also be an integer, and by
definition integer division always rounds *down*, even in cases like
this where the next integer is so close.

A possible alternative in this case is to calculate a percentage rather
than a fraction:

::

      cout << "Percentage of the hour that has passed: ";
      cout << minute*100/60 << endl;

The result is:

::

    Percentage of the hour that has passed: 98

Again the result is rounded down, but at least now the answer is
approximately correct. In order to get an even more accurate answer, we
could use a different type of variable, called floating-point, that is
capable of storing fractional values. We’ll get to that in the next
chapter.

Order of operations
-------------------

When more than one operator appears in an expression the order of
evaluation depends on the rules of **precedence**. A complete
explanation of precedence can get complicated, but just to get you
started:

-  Multiplication and division happen before addition and subtraction.
   So 2*3-1 yields 5, not 4, and 2/3-1 yields -1, not 1 (remember that
   in integer division 2/3 is 0).

-  If the operators have the same precedence they are evaluated from
   left to right. So in the expression minute*100/60, the multiplication
   happens first, yielding 5900/60, which in turn yields 98. If the
   operations had gone from right to left, the result would be 59*1
   which is 59, which is wrong.

-  Any time you want to override the rules of precedence (or you are not
   sure what they are) you can use parentheses. Expressions in
   parentheses are evaluated first, so 2 \* (3-1) is 4. You can also use
   parentheses to make an expression easier to read, as in (minute \*
   100) / 60, even though it doesn’t change the result.

Operators for characters
------------------------

Interestingly, the same mathematical operations that work on integers
also work on characters. For example,

::

      char letter;
      letter = 'a' + 1;
      cout << letter << endl;

outputs the letter b. Although it is syntactically legal to multiply
characters, it is almost never useful to do it.

Earlier I said that you can only assign integer values to integer
variables and character values to character variables, but that is not
completely true. In some cases, C++ converts automatically between
types. For example, the following is legal.

::

      int number;
      number = 'a';
      cout << number << endl;

The result is 97, which is the number that is used internally by C++ to
represent the letter ’a’. However, it is generally a good idea to treat
characters as characters, and integers as integers, and only convert
from one to the other if there is a good reason.

Automatic type conversion is an example of a common problem in designing
a programming language, which is that there is a conflict between
**formalism**, which is the requirement that formal languages should
have simple rules with few exceptions, and **convenience**, which is the
requirement that programming languages be easy to use in practice.

More often than not, convenience wins, which is usually good for expert
programmers, who are spared from rigorous but unwieldy formalism, but
bad for beginning programmers, who are often baffled by the complexity
of the rules and the number of exceptions. In this book I have tried to
simplify things by emphasizing the rules and omitting many of the
exceptions.

Composition
-----------

So far we have looked at the elements of a programming
language—variables, expressions, and statements—in isolation, without
talking about how to combine them.

One of the most useful features of programming languages is their
ability to take small building blocks and **compose** them. For example,
we know how to multiply integers and we know how to output values; it
turns out we can do both at the same time:

::

        cout << 17 * 3;

Actually, I shouldn’t say “at the same time,” since in reality the
multiplication has to happen before the output, but the point is that
any expression, involving numbers, characters, and variables, can be
used inside an output statement. We’ve already seen one example:

::

      cout << hour*60 + minute << endl;

You can also put arbitrary expressions on the right-hand side of an
assignment statement:

::

      int percentage;
      percentage = (minute * 100) / 60;

This ability may not seem so impressive now, but we will see other
examples where composition makes it possible to express complex
computations neatly and concisely.

WARNING: There are limits on where you can use certain expressions; most
notably, the left-hand side of an assignment statement has to be a
*variable* name, not an expression. That’s because the left side
indicates the storage location where the result will go. Expressions do
not represent storage locations, only values. So the following is
illegal: minute+1 = hour;.

Glossary
--------

variable:
    A named storage location for values. All variables have a type,
    which determines which values it can store.

value:
    A letter, or number, or other thing that can be stored in a
    variable.

type:
    A set of values. The types we have seen are integers (int in C++)
    and characters ( char in C++).

keyword:
    A reserved word that is used by the compiler to parse programs.
    Examples we have seen include int, void and endl.

statement:
    A line of code that represents a command or action. So far, the
    statements we have seen are declarations, assignments, and output
    statements.

declaration:
    A statement that creates a new variable and determines its type.

assignment:
    A statement that assigns a value to a variable.

expression:
    A combination of variables, operators and values that represents a
    single result value. Expressions also have types, as determined by
    their operators and operands.

operator:
    A special symbol that represents a simple computation like addition
    or multiplication.

operand:
    One of the values on which an operator operates.

precedence:
    The order in which operations are evaluated.

composition:
    The ability to combine simple expressions and statements into
    compound statements and expressions in order to represent complex
    computations concisely.
